package data.service

import bose.ankush.data.model.*
import com.itextpdf.barcodes.BarcodeQRCode
import com.itextpdf.kernel.colors.ColorConstants
import com.itextpdf.kernel.pdf.PdfDocument
import com.itextpdf.kernel.pdf.PdfWriter
import com.itextpdf.layout.Document
import com.itextpdf.layout.element.Cell
import com.itextpdf.layout.element.Image
import com.itextpdf.layout.element.Paragraph
import com.itextpdf.layout.element.Table
import com.itextpdf.layout.properties.HorizontalAlignment
import com.itextpdf.layout.properties.TextAlignment
import com.itextpdf.layout.properties.UnitValue
import domain.model.Result
import domain.repository.PaymentRepository
import domain.repository.UserRepository
import domain.service.BillService
import domain.service.EmailService
import domain.service.RefundService
import org.slf4j.LoggerFactory
import java.io.ByteArrayOutputStream
import java.time.Instant
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.*

/**
 * Implementation of BillService using iText for PDF generation.
 */
class BillServiceImpl(
    private val paymentRepository: PaymentRepository,
    private val userRepository: UserRepository,
    private val emailService: EmailService,
    private val refundService: RefundService
) : BillService {
    private val logger = LoggerFactory.getLogger(BillServiceImpl::class.java)

    override suspend fun generateBill(
        userEmail: String,
        paymentIds: List<String>
    ): Result<ByteArray> {
        logger.debug("Generating bill for user: $userEmail")
        return try {
            // Fetch user
            val userResult = userRepository.findUserByEmail(userEmail)
            if (userResult is Result.Error) {
                return Result.error("User not found: ${userResult.message}")
            }

            // Fetch payments
            val paymentsResult = paymentRepository.getPaymentsByUserEmail(userEmail)
            if (paymentsResult is Result.Error) {
                return Result.error("Failed to fetch payments: ${paymentsResult.message}")
            }
            val allPayments = (paymentsResult as Result.Success).data
            val selectedPayments = allPayments.filter { paymentIds.contains(it.id) }

            // Generate invoice number
            val invoiceNumber = generateInvoiceNumber()

            // Generate PDF
            val pdfBytes = createPdfInvoice(
                invoiceNumber = invoiceNumber,
                userEmail = userEmail,
                payments = selectedPayments
            )

            logger.debug("Bill generated successfully: $invoiceNumber")
            Result.success(pdfBytes)
        } catch (e: Exception) {
            logger.error("Failed to generate bill", e)
            Result.error("Failed to generate bill: ${e.message}", e)
        }
    }

    override suspend fun generateAndSendBill(
        adminEmail: String,
        userEmail: String,
        paymentIds: List<String>
    ): Result<BillGenerationResponse> {
        logger.debug("Generating and sending bill for user: $userEmail by admin: $adminEmail")
        return try {
            // Generate PDF
            val billResult = generateBill(userEmail, paymentIds)
            if (billResult is Result.Error) {
                return Result.error(billResult.message)
            }
            val pdfBytes = (billResult as Result.Success).data
            val invoiceNumber = generateInvoiceNumber()

            // Send via email with attachment
            var emailSent = false
            var emailError: String? = null

            try {
                val emailSubject = "Your Invoice - $invoiceNumber"
                val emailHtmlContent = buildBillEmailHtml(invoiceNumber)
                val filename = "$invoiceNumber.pdf"

                val emailResult = emailService.sendEmailWithAttachment(
                    userEmail = userEmail,
                    subject = emailSubject,
                    htmlContent = emailHtmlContent,
                    attachmentData = pdfBytes,
                    attachmentFilename = filename
                )

                emailSent = emailResult is Result.Success && emailResult.data == true
                if (emailResult is Result.Error) {
                    emailError = emailResult.message
                }

                logger.info("Bill sent via email to $userEmail: $invoiceNumber (success: $emailSent)")
            } catch (e: Exception) {
                logger.warn("Failed to send bill via email", e)
                emailError = e.message
            }

            val response = BillGenerationResponse(
                success = true,
                message = if (emailSent) "Bill generated and sent successfully via email"
                else "Bill generated successfully. ${emailError ?: "Email not sent"}",
                invoiceNumber = invoiceNumber,
                emailSent = emailSent
            )

            logger.info("Bill generated by admin $adminEmail for user $userEmail: $invoiceNumber")
            Result.success(response)
        } catch (e: Exception) {
            logger.error("Failed to generate and send bill", e)
            Result.error("Failed to generate and send bill: ${e.message}", e)
        }
    }

    override suspend fun generateOriginalBill(paymentId: String): Result<ByteArray> {
        return generatePaymentBill(paymentId, BillType.ORIGINAL_BILL)
    }

    override suspend fun generateRefundAdjustmentBill(paymentId: String): Result<ByteArray> {
        return generatePaymentBill(paymentId, BillType.REFUND_ADJUSTMENT_BILL)
    }

    override suspend fun generateNetAmountBill(paymentId: String): Result<ByteArray> {
        return generatePaymentBill(paymentId, BillType.NET_AMOUNT_BILL)
    }

    override suspend fun generateRefundReceipt(paymentId: String): Result<ByteArray> {
        return generatePaymentBill(paymentId, BillType.REFUND_RECEIPT)
    }

    override suspend fun sendPaymentBillEmail(
        userEmail: String,
        paymentId: String
    ): Result<Boolean> {
        logger.debug("Sending payment bill email to $userEmail for payment $paymentId")

        val paymentResult = paymentRepository.getPaymentByTransactionId(paymentId)
        if (paymentResult is Result.Error) {
            return Result.error("Failed to fetch payment: ${paymentResult.message}")
        }
        val payment = (paymentResult as Result.Success).data
            ?: return Result.error("Payment not found: $paymentId")

        if (!payment.userEmail.equals(userEmail, ignoreCase = true)) {
            return Result.error("Payment does not belong to the specified user")
        }

        val pdfResult = generateOriginalBill(paymentId)
        if (pdfResult is Result.Error) {
            return Result.error(pdfResult.message)
        }
        val pdfBytes = (pdfResult as Result.Success).data

        val emailSubject = "Payment receipt and invoice - ${payment.paymentId}"
        val emailHtmlContent = buildPaymentEmailHtml(payment)
        val filename = "payment-${payment.paymentId}.pdf"

        return emailService.sendEmailWithAttachment(
            userEmail = userEmail,
            subject = emailSubject,
            htmlContent = emailHtmlContent,
            attachmentData = pdfBytes,
            attachmentFilename = filename
        )
    }

    /**
     * Generates a unique invoice number using timestamp and random suffix.
     * Format: INV-{timestamp}-{random}
     *
     * Example: INV-1627660800123-456
     *
     * @return Unique invoice number string
     */
    private fun generateInvoiceNumber(): String {
        val timestamp = System.currentTimeMillis()
        val random = Random().nextInt(1000)
        return "INV-${timestamp}-${random}"
    }

    /**
     * Creates a PDF invoice document using iText library.
     *
     * The invoice includes:
     * - Company header and branding
     * - Invoice metadata (number, dates)
     * - Customer information
     * - Itemized list of charges (payments)
     * - Subtotal, tax, and total calculations
     * - Payment instructions and footer
     *
     * @param invoiceNumber Unique invoice identifier
     * @param userEmail Customer email address
     * @param payments List of payment records to include
     * @return PDF document as byte array
     */
    private fun createPdfInvoice(
        invoiceNumber: String,
        userEmail: String,
        payments: List<Payment>
    ): ByteArray {
        // Use ByteArrayOutputStream to generate PDF in memory
        val outputStream = ByteArrayOutputStream()
        val writer = PdfWriter(outputStream)
        val pdfDoc = PdfDocument(writer)
        val document = Document(pdfDoc)

        try {
            // === HEADER SECTION ===
            // Add centered "INVOICE" title
            document.add(
                Paragraph("INVOICE")
                    .setFontSize(24f)
                    .setBold()
                    .setTextAlignment(TextAlignment.CENTER)
            )

            document.add(Paragraph("\n"))

            // Add company information
            document.add(
                Paragraph("Androidplay")
                    .setFontSize(14f)
                    .setBold()
            )
            document.add(Paragraph("Weather API Services"))
            document.add(Paragraph("https://androidplay.com"))
            document.add(Paragraph("\n"))

            // === INVOICE METADATA SECTION ===
            // Calculate invoice and due dates
            val now = Instant.now()
            val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
                .withZone(ZoneId.systemDefault())
            val invoiceDate = formatter.format(now)
            val dueDate = formatter.format(now.plusSeconds(30L * 24 * 60 * 60)) // 30 days from now

            // Create 2-column table for metadata (label on left, value on right)
            val metadataTable = Table(UnitValue.createPercentArray(floatArrayOf(1f, 1f)))
                .useAllAvailableWidth()

            metadataTable.addCell(
                Cell().add(Paragraph("Invoice Number:").setBold())
                    .setBorder(null)
            )
            metadataTable.addCell(
                Cell().add(Paragraph(invoiceNumber))
                    .setBorder(null)
                    .setTextAlignment(TextAlignment.RIGHT)
            )

            metadataTable.addCell(
                Cell().add(Paragraph("Invoice Date:").setBold())
                    .setBorder(null)
            )
            metadataTable.addCell(
                Cell().add(Paragraph(invoiceDate))
                    .setBorder(null)
                    .setTextAlignment(TextAlignment.RIGHT)
            )

            metadataTable.addCell(
                Cell().add(Paragraph("Due Date:").setBold())
                    .setBorder(null)
            )
            metadataTable.addCell(
                Cell().add(Paragraph(dueDate))
                    .setBorder(null)
                    .setTextAlignment(TextAlignment.RIGHT)
            )

            document.add(metadataTable)
            document.add(Paragraph("\n"))

            // === CUSTOMER INFORMATION ===
            document.add(Paragraph("Bill To:").setBold())
            document.add(Paragraph(userEmail))
            document.add(Paragraph("\n"))

            // === ITEMIZED CHARGES TABLE ===
            // Create 3-column table: Description (60%), Service Period (30%), Amount (10%)
            val itemsTable = Table(UnitValue.createPercentArray(floatArrayOf(3f, 2f, 1f)))
                .useAllAvailableWidth()

            // Add header row with gray background
            itemsTable.addHeaderCell(
                Cell().add(Paragraph("Description").setBold())
                    .setBackgroundColor(ColorConstants.LIGHT_GRAY)
            )
            itemsTable.addHeaderCell(
                Cell().add(Paragraph("Service Period").setBold())
                    .setBackgroundColor(ColorConstants.LIGHT_GRAY)
            )
            itemsTable.addHeaderCell(
                Cell().add(Paragraph("Amount").setBold())
                    .setBackgroundColor(ColorConstants.LIGHT_GRAY)
                    .setTextAlignment(TextAlignment.RIGHT)
            )

            var subtotal = 0.0

            // Add each payment as a line item
            // Amounts are stored in paise/cents, so divide by 100
            payments.forEach { payment ->
                val amount = (payment.amount ?: 0).toDouble() / 100.0
                subtotal += amount

                itemsTable.addCell(Cell().add(Paragraph("Payment - ${payment.status}")))
                itemsTable.addCell(Cell().add(Paragraph(formatDate(payment.createdAt))))
                itemsTable.addCell(
                    Cell().add(Paragraph("${payment.currency ?: "INR"} %.2f".format(amount)))
                        .setTextAlignment(TextAlignment.RIGHT)
                )
            }

            document.add(itemsTable)
            document.add(Paragraph("\n"))

            // === TOTALS SECTION ===
            // Create 2-column table for totals (label on left, amount on right)
            val totalsTable = Table(UnitValue.createPercentArray(floatArrayOf(4f, 1f)))
                .useAllAvailableWidth()

            totalsTable.addCell(
                Cell().add(Paragraph("Subtotal:").setBold())
                    .setBorder(null)
                    .setTextAlignment(TextAlignment.RIGHT)
            )
            totalsTable.addCell(
                Cell().add(Paragraph("INR %.2f".format(subtotal)))
                    .setBorder(null)
                    .setTextAlignment(TextAlignment.RIGHT)
            )

            // Tax calculation (currently 0% - can be updated based on business requirements)
            totalsTable.addCell(
                Cell().add(Paragraph("Tax (0%):").setBold())
                    .setBorder(null)
                    .setTextAlignment(TextAlignment.RIGHT)
            )
            totalsTable.addCell(
                Cell().add(Paragraph("INR 0.00"))
                    .setBorder(null)
                    .setTextAlignment(TextAlignment.RIGHT)
            )

            // Total (larger font for emphasis)
            totalsTable.addCell(
                Cell().add(Paragraph("Total:").setBold().setFontSize(14f))
                    .setBorder(null)
                    .setTextAlignment(TextAlignment.RIGHT)
            )
            totalsTable.addCell(
                Cell().add(Paragraph("INR %.2f".format(subtotal)).setBold().setFontSize(14f))
                    .setBorder(null)
                    .setTextAlignment(TextAlignment.RIGHT)
            )

            document.add(totalsTable)
            document.add(Paragraph("\n\n"))

            // === PAYMENT INSTRUCTIONS ===
            document.add(Paragraph("Payment Instructions:").setBold())
            document.add(Paragraph("Thank you for using Androidplay Weather API services."))
            document.add(Paragraph("For any questions regarding this invoice, please contact support."))
            document.add(Paragraph("\n"))

            // === FOOTER ===
            document.add(
                Paragraph("Thank you for your business!")
                    .setTextAlignment(TextAlignment.CENTER)
                    .setFontSize(10f)
            )

        } finally {
            // Always close the document to finalize the PDF
            document.close()
        }

        return outputStream.toByteArray()
    }

    private suspend fun generatePaymentBill(paymentId: String, billType: BillType): Result<ByteArray> {
        return try {
            val paymentResult = paymentRepository.getPaymentByTransactionId(paymentId)
            if (paymentResult is Result.Error) {
                return Result.error("Failed to find payment: ${paymentResult.message}")
            }
            val payment = (paymentResult as Result.Success).data
                ?: return Result.error("Payment not found: $paymentId")

            val amountPaise = payment.amount ?: 0
            if (amountPaise <= 0) {
                return Result.error("Payment amount is zero; cannot generate bill")
            }

            val userResult = userRepository.findUserByEmail(payment.userEmail)
            val user = if (userResult is Result.Success) userResult.data else null

            val refundSummary = when (val refundResult = refundService.getRefundsForPayment(paymentId)) {
                is Result.Success -> refundResult.data
                is Result.Error -> null
            }

            val totalRefunded = refundSummary?.totalRefunded ?: 0
            if (totalRefunded > amountPaise) {
                return Result.error("Refund amount exceeds original payment amount")
            }

            val isFullyRefunded = totalRefunded == amountPaise
            val isPartiallyRefunded = totalRefunded in 1 until amountPaise
            val isNonRefunded = totalRefunded == 0 || payment.status.equals("PAID", ignoreCase = true)

            val billTypeAllowed = when (billType) {
                BillType.ORIGINAL_BILL -> isNonRefunded || isPartiallyRefunded
                BillType.REFUND_ADJUSTMENT_BILL -> isPartiallyRefunded
                BillType.NET_AMOUNT_BILL -> isPartiallyRefunded
                BillType.REFUND_RECEIPT -> isFullyRefunded
            }

            if (!billTypeAllowed) {
                return Result.error("Selected bill type is not available for this payment")
            }

            val pdfBytes = createPaymentBillPdf(
                billType = billType,
                payment = payment,
                user = user,
                refundSummary = refundSummary
            )

            Result.success(pdfBytes)
        } catch (e: Exception) {
            logger.error("Failed to generate payment bill for $paymentId", e)
            Result.error("Failed to generate bill: ${e.message}", e)
        }
    }

    private fun createPaymentBillPdf(
        billType: BillType,
        payment: Payment,
        user: User?,
        refundSummary: PaymentRefundSummary?
    ): ByteArray {
        val outputStream = ByteArrayOutputStream()
        val writer = PdfWriter(outputStream)
        val pdfDoc = PdfDocument(writer)
        val document = Document(pdfDoc)

        try {
            val amountPaise = payment.amount ?: 0
            val totalRefundedPaise = refundSummary?.totalRefunded ?: 0
            val netPaise = (amountPaise - totalRefundedPaise).coerceAtLeast(0)

            val headerTitle = when (billType) {
                BillType.ORIGINAL_BILL -> "ORIGINAL BILL"
                BillType.REFUND_ADJUSTMENT_BILL -> "REFUND ADJUSTMENT BILL"
                BillType.NET_AMOUNT_BILL -> "NET AMOUNT BILL"
                BillType.REFUND_RECEIPT -> "REFUND RECEIPT"
            }

            document.add(
                Paragraph(headerTitle)
                    .setFontSize(20f)
                    .setBold()
                    .setTextAlignment(TextAlignment.CENTER)
            )
            document.add(Paragraph("\n"))

            // Customer details
            val detailsTable = Table(UnitValue.createPercentArray(floatArrayOf(1f, 1f)))
                .useAllAvailableWidth()
            detailsTable.addCell(simpleCell("Customer Name:", true))
            detailsTable.addCell(simpleCell(user?.email ?: "N/A", false, TextAlignment.RIGHT))
            detailsTable.addCell(simpleCell("Customer Email:", true))
            detailsTable.addCell(simpleCell(payment.userEmail, false, TextAlignment.RIGHT))
            detailsTable.addCell(simpleCell("Customer Phone:", true))
            detailsTable.addCell(simpleCell("N/A", false, TextAlignment.RIGHT))
            document.add(detailsTable)
            document.add(Paragraph("\n"))

            // Payment metadata
            val paymentDate = formatBillDateTime(payment.createdAt)
            val refundDate = refundSummary?.refunds
                ?.maxOfOrNull { it.processedAt ?: it.createdAt }
                ?.let { formatBillDateTime(it) }
                ?: paymentDate
            val statusText = payment.status ?: "UNKNOWN"

            val metaTable = Table(UnitValue.createPercentArray(floatArrayOf(1f, 1f)))
                .useAllAvailableWidth()
            metaTable.addCell(simpleCell("Payment Reference:", true))
            metaTable.addCell(simpleCell(payment.paymentId, false, TextAlignment.RIGHT))
            metaTable.addCell(simpleCell("Date:", true))
            metaTable.addCell(
                simpleCell(
                    if (billType == BillType.REFUND_RECEIPT) refundDate else paymentDate,
                    false,
                    TextAlignment.RIGHT
                )
            )
            metaTable.addCell(simpleCell("Payment Status:", true))
            metaTable.addCell(
                Cell()
                    .add(Paragraph(statusText).setBold())
                    .setBackgroundColor(statusColor(statusText))
                    .setBorder(null)
                    .setTextAlignment(TextAlignment.RIGHT)
                    .setPadding(4f)
            )
            document.add(metaTable)
            document.add(Paragraph("\n"))

            // QR Code
            val qrCode = BarcodeQRCode(payment.paymentId)
            val qrImage = Image(qrCode.createFormXObject(ColorConstants.BLACK, pdfDoc))
                .setWidth(80f)
                .setHeight(80f)
                .setHorizontalAlignment(HorizontalAlignment.RIGHT)
            document.add(qrImage)
            document.add(Paragraph("\n"))

            // Itemized table
            val itemTable = Table(UnitValue.createPercentArray(floatArrayOf(3f, 2f, 2f, 2f)))
                .useAllAvailableWidth()
            itemTable.addHeaderCell(simpleCell("Description", true))
            itemTable.addHeaderCell(simpleCell("Amount", true, TextAlignment.RIGHT))
            itemTable.addHeaderCell(simpleCell("Refund", true, TextAlignment.RIGHT))
            itemTable.addHeaderCell(simpleCell("Net", true, TextAlignment.RIGHT))

            when (billType) {
                BillType.ORIGINAL_BILL -> {
                    itemTable.addCell(simpleCell("Payment", false))
                    itemTable.addCell(simpleCell(formatCurrency(amountPaise), false, TextAlignment.RIGHT))
                    itemTable.addCell(simpleCell(formatCurrency(0), false, TextAlignment.RIGHT))
                    itemTable.addCell(simpleCell(formatCurrency(amountPaise), false, TextAlignment.RIGHT))
                }

                BillType.REFUND_ADJUSTMENT_BILL -> {
                    val refunds = refundSummary?.refunds ?: emptyList()
                    if (refunds.isEmpty()) {
                        itemTable.addCell(simpleCell("No refunds recorded", false))
                        itemTable.addCell(simpleCell("-", false, TextAlignment.RIGHT))
                        itemTable.addCell(simpleCell("-", false, TextAlignment.RIGHT))
                        itemTable.addCell(simpleCell("-", false, TextAlignment.RIGHT))
                    } else {
                        refunds.forEach { refund ->
                            val refundPaise = Math.round(refund.amount * 100).toInt()
                            itemTable.addCell(simpleCell("Refund ${refund.refundId}", false))
                            itemTable.addCell(simpleCell("-", false, TextAlignment.RIGHT))
                            itemTable.addCell(simpleCell(formatCurrency(refundPaise), false, TextAlignment.RIGHT))
                            itemTable.addCell(simpleCell("-", false, TextAlignment.RIGHT))
                        }
                    }
                }

                BillType.NET_AMOUNT_BILL -> {
                    itemTable.addCell(simpleCell("Payment (net of refunds)", false))
                    itemTable.addCell(simpleCell(formatCurrency(amountPaise), false, TextAlignment.RIGHT))
                    itemTable.addCell(simpleCell(formatCurrency(totalRefundedPaise), false, TextAlignment.RIGHT))
                    itemTable.addCell(simpleCell(formatCurrency(netPaise), false, TextAlignment.RIGHT))
                }

                BillType.REFUND_RECEIPT -> {
                    itemTable.addCell(simpleCell("Refunded Payment", false))
                    itemTable.addCell(simpleCell(formatCurrency(amountPaise), false, TextAlignment.RIGHT))
                    itemTable.addCell(simpleCell(formatCurrency(totalRefundedPaise), false, TextAlignment.RIGHT))
                    itemTable.addCell(simpleCell(formatCurrency(0), false, TextAlignment.RIGHT))
                }
            }

            document.add(itemTable)
            document.add(Paragraph("\n"))

            // Totals section
            val totalsTable = Table(UnitValue.createPercentArray(floatArrayOf(2f, 2f)))
                .useAllAvailableWidth()
            totalsTable.addCell(simpleCell("Original Amount", true))
            totalsTable.addCell(simpleCell(formatCurrency(amountPaise), false, TextAlignment.RIGHT))
            if (totalRefundedPaise > 0) {
                totalsTable.addCell(simpleCell("Refund Amount", true))
                totalsTable.addCell(simpleCell(formatCurrency(totalRefundedPaise), false, TextAlignment.RIGHT))
            }
            totalsTable.addCell(simpleCell("Net Amount", true))
            totalsTable.addCell(simpleCell(formatCurrency(netPaise), false, TextAlignment.RIGHT))
            document.add(totalsTable)

            document.add(Paragraph("\n"))
            document.add(
                Paragraph("Terms: This document is system-generated. For questions, contact support@androidplay.com.")
                    .setFontSize(9f)
                    .setTextAlignment(TextAlignment.CENTER)
            )
        } finally {
            document.close()
        }

        return outputStream.toByteArray()
    }

    private fun formatCurrency(amountPaise: Int): String {
        val value = amountPaise.toDouble() / 100.0
        return String.format(Locale.ENGLISH, "â‚¹%.2f", value)
    }

    private fun formatBillDateTime(dateString: String?): String {
        if (dateString.isNullOrBlank()) return "N/A"
        return try {
            val instant = Instant.parse(dateString)
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")
                .withZone(ZoneId.systemDefault())
                .format(instant)
        } catch (_: Exception) {
            dateString
        }
    }

    private fun simpleCell(
        text: String,
        isHeader: Boolean,
        alignment: TextAlignment = TextAlignment.LEFT
    ): Cell {
        val paragraph = Paragraph(text)
        if (isHeader) {
            paragraph.setBold()
        }
        val cell = Cell()
            .add(paragraph)
            .setBorder(null)
            .setTextAlignment(alignment)
        if (isHeader) {
            cell.setBackgroundColor(ColorConstants.LIGHT_GRAY)
        }
        return cell
    }

    private fun statusColor(status: String): com.itextpdf.kernel.colors.Color {
        return when (status.uppercase()) {
            "REFUNDED" -> ColorConstants.LIGHT_GRAY
            "FAILED" -> ColorConstants.PINK
            "PENDING" -> ColorConstants.YELLOW
            else -> ColorConstants.GREEN
        }
    }

    /**
     * Formats an ISO 8601 date string to a human-readable format.
     *
     * @param dateString ISO 8601 formatted date string (e.g., "2024-02-15T10:30:00Z")
     * @return Formatted date string (e.g., "Feb 15, 2024") or original string if parsing fails
     */
    private fun formatDate(dateString: String): String {
        return try {
            val instant = Instant.parse(dateString)
            val formatter = DateTimeFormatter.ofPattern("MMM dd, yyyy")
                .withZone(ZoneId.systemDefault())
            formatter.format(instant)
        } catch (_: Exception) {
            // Return original string if parsing fails
            dateString
        }
    }

    /**
     * Builds HTML email content for bill notification
     *
     * @param invoiceNumber The invoice number
     * @param userEmail The user's email address
     * @return HTML email content
     */
    private fun buildBillEmailHtml(invoiceNumber: String): String {
        return """
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <style>
                    body {
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                        line-height: 1.6;
                        color: #333;
                        max-width: 600px;
                        margin: 0 auto;
                        padding: 20px;
                    }
                    .container {
                        background-color: #f9f9f9;
                        border-radius: 8px;
                        padding: 30px;
                        border: 1px solid #e0e0e0;
                    }
                    .header {
                        text-align: center;
                        margin-bottom: 30px;
                    }
                    .header h1 {
                        color: #2c3e50;
                        margin: 0;
                        font-size: 24px;
                    }
                    .content {
                        background-color: white;
                        padding: 25px;
                        border-radius: 6px;
                        margin-bottom: 20px;
                    }
                    .info-box {
                        background-color: #e3f2fd;
                        border-left: 4px solid #2196f3;
                        padding: 15px;
                        margin: 20px 0;
                        border-radius: 4px;
                    }
                    .invoice-number {
                        font-size: 20px;
                        font-weight: bold;
                        color: #2196f3;
                        text-align: center;
                        margin: 20px 0;
                        padding: 15px;
                        background-color: #f5f5f5;
                        border-radius: 6px;
                    }
                    .footer {
                        text-align: center;
                        color: #666;
                        font-size: 14px;
                        margin-top: 20px;
                    }
                    .attachment-note {
                        background-color: #fff3cd;
                        border-left: 4px solid #ffc107;
                        padding: 12px;
                        margin: 15px 0;
                        border-radius: 4px;
                        font-size: 14px;
                    }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>ðŸ“„ Your Invoice is Ready</h1>
                    </div>
                    <div class="content">
                        <p>Hello,</p>
                        <p>Thank you for using Androidplay Weather API services. Your invoice has been generated and is attached to this email.</p>

                        <div class="invoice-number">
                            Invoice #$invoiceNumber
                        </div>

                        <div class="attachment-note">
                            <strong>ðŸ“Ž Attachment:</strong> Please find your invoice attached as a PDF file. You can download and save it for your records.
                        </div>

                        <div class="info-box">
                            <strong>Need Help?</strong> If you have any questions about this invoice or need assistance, please don't hesitate to contact our support team.
                        </div>

                        <p>We appreciate your business and look forward to continuing to serve you.</p>
                    </div>
                    <div class="footer">
                        <p>Thank you for using Androidplay</p>
                        <p style="font-size: 12px; color: #999;">This is an automated message. Please do not reply to this email.</p>
                    </div>
                </div>
            </body>
            </html>
        """.trimIndent()
    }

    private fun buildPaymentEmailHtml(payment: Payment): String {
        val amountText = payment.amount?.let {
            String.format(Locale.ENGLISH, "INR %.2f", it.toDouble() / 100.0)
        } ?: "N/A"
        val statusText = payment.status ?: "N/A"
        val serviceTypeText = payment.serviceType?.name ?: "N/A"
        val receiptText = payment.receipt ?: "N/A"
        val paymentDate = formatBillDateTime(payment.verifiedAt ?: payment.createdAt)

        return """
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <style>
                    body {
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                        line-height: 1.6;
                        color: #333;
                        max-width: 600px;
                        margin: 0 auto;
                        padding: 20px;
                    }
                    .container {
                        background-color: #f9f9f9;
                        border-radius: 8px;
                        padding: 30px;
                        border: 1px solid #e0e0e0;
                    }
                    .header {
                        text-align: center;
                        margin-bottom: 24px;
                    }
                    .header h1 {
                        color: #2c3e50;
                        margin: 0;
                        font-size: 22px;
                    }
                    .content {
                        background-color: white;
                        padding: 20px;
                        border-radius: 6px;
                        margin-bottom: 20px;
                    }
                    .details {
                        background-color: #f8f9fa;
                        padding: 15px;
                        border-radius: 4px;
                        margin: 15px 0;
                    }
                    .details p {
                        margin: 6px 0;
                    }
                    .attachment-note {
                        background-color: #fff3cd;
                        border-left: 4px solid #ffc107;
                        padding: 12px;
                        margin: 15px 0;
                        border-radius: 4px;
                        font-size: 14px;
                    }
                    .footer {
                        text-align: center;
                        color: #666;
                        font-size: 14px;
                        margin-top: 20px;
                    }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>Payment receipt and invoice</h1>
                    </div>
                    <div class="content">
                        <p>Hello,</p>
                        <p>Thank you for your subscription purchase. Your payment has been verified and your bill is attached.</p>

                        <div class="details">
                            <p><strong>Payment ID:</strong> ${payment.paymentId}</p>
                            <p><strong>Order ID:</strong> ${payment.orderId}</p>
                            <p><strong>Receipt:</strong> $receiptText</p>
                            <p><strong>Service:</strong> $serviceTypeText</p>
                            <p><strong>Amount:</strong> $amountText</p>
                            <p><strong>Status:</strong> $statusText</p>
                            <p><strong>Verified At:</strong> $paymentDate</p>
                        </div>

                        <div class="attachment-note">
                            <strong>Attachment:</strong> Your bill is attached as a PDF for your records.
                        </div>

                        <p>If you have any questions, please contact our support team.</p>
                    </div>
                    <div class="footer">
                        <p>Thank you for using Androidplay</p>
                        <p style="font-size: 12px; color: #999;">This is an automated message. Please do not reply to this email.</p>
                    </div>
                </div>
            </body>
            </html>
        """.trimIndent()
    }
}
